#ifndef DF_GENERATOR_H
#define DF_GENERATOR_H

#include <limits>
#include <cmath>
#include <iostream>
#include <vector>
#include <algorithm>

#include "types.h"

namespace DiceForge
{
    /// @brief DiceForge::Generator<T> - A generic class for RNGs
    /// @tparam T datatype of random number generated (RNG implementation specific)
    /// @note Every RNG implemented in DiceForge is derived from this base class.
    /// @note For writing your own RNG it is advisable to use this as the base class for compatibility with other features.
    template <typename T>
    class Generator
    {
    public:
        /// @brief Returns a random integer generated by the RNG
        /// @returns An unsigned integer (usually 32 or 64 bit)
        T next()
        {
            return generate();
        };
        /// @brief Returns a random real between 0 and 1
        /// @returns An floating-point real number (64 bit)
        real_t next_unit()
        {
            real_t x = 1.0;
            while (x == 1.0) {
                x = generate() / real_t(std::numeric_limits<T>().max());
            }
            return x;
        }
        /// @brief Returns a random integer in the specified range
        /// @param min minimum value of the random number (inclusive)
        /// @param max maximum value of the random number (inclusive)
        /// @returns An signed integer (64 bit)
        int64_t next_in_range(T min, T max)
        {
            return (int64_t)floor(next_unit() * (max - min + 1)) + min;
        };
        /// @brief Returns a random real number in the specified range
        /// @param min minimum value of the random number
        /// @param max maximum value of the random number
        /// @returns An signed floating-point real number (64 bit)
        real_t next_in_crange(real_t min, real_t max)
        {
            real_t x = (real_t)max;
            while (x == max) {
                x = (max - min) * next_unit() + min;
            }
            return x;
        };
        /// @brief Re-initializes the RNG with specified seed
        /// @param seed seed provided for initialization
        void reset_seed(T seed)
        {
            reseed(seed);
        }
        
        /// @brief Returns a uniformly chosen random element from the sequence
        /// @param first Iterator of first element (like .begin() of vectors)
        /// @param last Iterator after last element (like .end() of vectors)
        template <typename RandomAccessIterator>
        auto choice(RandomAccessIterator first, RandomAccessIterator last)
        {
            return *(first + next_in_range(0, last - first - 1));
        };

        /// @brief Returns a uniformly chosen random element from the sequence
        /// @param first Iterator of first element (like .begin() of vectors)
        /// @param last Iterator after last element (like .end() of vectors)
        /// @param first Iterator of weight of first element (like .begin() of vectors)
        /// @param last Iterator after weight of last element (like .end() of vectors)
        template <typename RandomAccessIterator1, typename RandomAccessIterator2>
        auto choice(RandomAccessIterator1 first, RandomAccessIterator1 last,
                    RandomAccessIterator2 weights_first, RandomAccessIterator2 weights_last)
        {
            if (last - first != weights_last - weights_first){
                throw std::invalid_argument("Lengths of sequence and weight sequence must be equal!");
            }
            else if (last == first){
                throw std::invalid_argument("Sequence must have non-zero length!");
            }
            auto cumulative_weights = (decltype(&(*weights_first)))malloc(sizeof(*weights_first) * (last - first));
            auto prev = *weights_first;
            prev = 0;
            for (auto it = weights_first; it != weights_last; it++){
                cumulative_weights[it - weights_first] = prev + *it;
                prev = cumulative_weights[it - weights_first];
            }
            auto ans = *(first + (std::upper_bound(cumulative_weights, &(cumulative_weights[last - first - 1]) + 1, next_unit() * cumulative_weights[last - first - 1]) - cumulative_weights));
            free(cumulative_weights);
            return ans;
        };

        /// @brief Shuffles the sequence in place
        /// @param first Iterator of first element (like .begin() of vectors)
        /// @param last Iterator after last element (like .end() of vectors)
        template <typename RandomAccessIterator>
        void shuffle(RandomAccessIterator first, RandomAccessIterator last)
        {
            auto temp = (decltype(&(*first)))malloc(sizeof(*first) * (last - first));
            for (auto it = first; it != last; it++){
                temp[it - first] = *it;
            }
            shuffle_array(temp, last - first);
            for (auto it = first; it!= last; it++){
                *it = temp[it - first];
            }
        };
        /*** Note: These are the only functions to be implemented by the implementation RNG ***/
    private:
        /// @brief Should return a random integer generated by the RNG
        virtual T generate() = 0;
        /// @brief Should initialize the seed for the RNG
        virtual void reseed(T seed) = 0;
        /// @brief Shuffles the array in place
        /// @param arr Pointer to the first element
        /// @param len Length of the array
        template <typename other_T>
        void shuffle_array(other_T arr[], T len) {
            T ind;
            std::vector<other_T> v;
            for (int i = 0; i < len; i++) {
                v.push_back(arr[i]);
            }
            for (int i = 0; i < len; i++) {
                ind = next_in_range(0, len - i - 1);
                arr[i] = v[ind];
                v.erase(v.begin() + ind);
            }
        };
    };
}

#endif